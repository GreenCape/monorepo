#!/usr/bin/env bash

usage() {
  cat <<-EOT
Usage: mono pull [options] <repository> <ref>
   or: mono pull -h|--help

Pull recent changes fetches the given <ref> from the specified remote <repository> into the
corresponding subtree. As with normal git pull, this doesn’t remove your own local changes;
it just merges those changes into the latest <local-commit>.
With --squash, create only one commit that contains all the changes, rather than merging in
the entire history.

Arguments:

    <repository>  The repository url or directory name of the subproject.
    <ref>         The remote reference. Defaults to current branch.

Options:

  --squash               Merge subtree changes as a single commit.
  -h|--help              Show this help text.

EOT
}

pull_subtree () {
  REMOTE_NAME=$1
  BRANCH=$2
  OPT_SQUASH=$3
  DIRECTORY=$(get_prefix "$REMOTE_NAME") || exit 1
  if [[ ! -d "$DIRECTORY" ]]; then
    debug "Subtree $DIRECTORY is not included in this branch"
  else
    debug "$MONO_COMMAND: Prefix: $DIRECTORY"
    BRANCH=${BRANCH:-$(git rev-parse --abbrev-ref HEAD)} || exit 1
    debug "$MONO_COMMAND: Branch: $BRANCH"

    debug "$MONO_COMMAND: Pulling subtree from branch $BRANCH"
    debug "git subtree pull --prefix=\"$DIRECTORY\" \"$REMOTE_NAME\" \"$BRANCH\" $OPT_SQUASH"
    git subtree pull --prefix="$DIRECTORY" "$REMOTE_NAME" "$BRANCH" $OPT_SQUASH || exit 1
  fi
}

OPT_SQUASH=
OPT_ALL=0
POSITIONAL=()
while [[ $# -gt 0 ]]; do
  case $1 in
  --all)
    OPT_ALL=1
    shift # past argument
    ;;
  --squash)
    OPT_SQUASH=" --squash"
    shift # past argument
    ;;
  --debug)
    OPT_DEBUG=1
    shift # past argument
    ;;
  -q)
    OPT_QUIET=1
    shift # past argument
    ;;
  -h | --help)
    usage
    exit 0
    ;;
  -*) # unknown option
    say "Unknown option »$1«"
    usage
    exit 1
    ;;
  *)
    POSITIONAL+=("$1") # save it in an array for later
    shift              # past argument
    ;;
  esac
done

source "$MONO_PLUGIN_DIR"/mono_commons
debug=$OPT_DEBUG
quiet=$OPT_QUIET

require_work_tree
ensure_clean

if [[ $OPT_ALL -eq 0 ]]; then
  REMOTE_NAME=${POSITIONAL[0]}
  BRANCH=${POSITIONAL[1]}
  if [[ ${#REMOTE_NAME} -eq 0 ]]; then
    say "$MONO_COMMAND: Remote name is required"
    exit 1
  fi
  pull_subtree "$REMOTE_NAME" "$BRANCH" $OPT_SQUASH
else
  BRANCH=${POSITIONAL[0]}
  while read remote_name prefix remote_url; do
    pull_subtree "$remote_name" "$BRANCH" $OPT_SQUASH
  done < .git/subtrees
fi

debug "$MONO_COMMAND: Done."
debug ""
